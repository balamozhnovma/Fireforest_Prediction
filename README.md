Решим задачу регрессии - прогнозирование площади лесных пожаров.

Воспользуемся датасетом Forest Fires Data Set (UCI). Он содержит следующие признаки:
* X - координата X пожара
* Y - координата Y пожара
* month - месяц пожара
* day - день недели пожара
* FFMC - индекс FFMC из системы FWI
* DMC - индекс DMC из системы FWI
* DC - индекс DC из системы FWI
* ISI - индекс ISI из системы FWI
* temp - температура
* RH - относительная влажность
* wind - скорость ветра
* rain - дождь
* area - площадь выгоревшего леса

Файлы проекта:
* requirements.txt - описание зависимостей
* eda.py - EDA 
* dataloader.py - обработка данных и разбиение на тест и трейн
* Forestfires_Prediction.py - обучение моделей
* dvc.yaml - DVC пайплайн
* app.py - веб-приложение, которое вернет предсказание
* Dockerfile - образ приложения
* deployemnt.yaml - манифест k8s, который управляет 3 подами
* service.yaml -  сервис для внутреннего доступа

1. **Eda.py**
   * Посмотрим на распределение целевой переменной. 
   Видим много нулей и редкие выбросы.
   * Посмотрим на взаимосвязь целевой переменной с месяцем, климатическими условиями и регионом. 
   Видно, что в мае и декабре самые большие по площади пожары. При этом в мае широкий разброс целевой переменной. 
   Пожары возникают, когда нет дождя (за исключением нескольких выбросов).
   Видна динамика: чем выше температура, тем чаще возникают пожары и тем больше их площадь. 
   Аналогично, чем выше относительная влажность, тем реже и с меньшей площадью возникают лесные пожары.
   Скорость ветра слабо коррелирует с целевой переменной.
   Чаще всего пожары возникают в регионе с координатами X от 2 до 4, Y = 4, при этом площадь пожара небольшая.
   * Посмотрим на наличие пропусков
   * Посмотрим на наличие категориальных признаков.
   Их всего два: месяц и день недели. Закодируем их с помощью OneHotEncoder.


2. **dataloader.py**
    * Разобьем выборку на обучающую и тестовую


3.  **Forestfires_Prediction.py**
   * Запустим эксперимент и обучим Random Forest в дочернем
   Он показал аномально высокие значения RMSE из-за выбросов. 
   * Обработаем выбросы и посмотрим на результат
   RMSE стал значительно ниже. Залогируем результат, параметры модели и саму модель.
   * Запустим второй дочерний эксперимент и обучим градиентный бустинг.
   Он показал результаты немного хуже, чем Random Forest, скорее всего, из-за малого числа n_estimators. Залогируем результат, параметры модели и саму модель.
   * Подберем гиперпараметры для XGBoost  помощью Optuna. Тюнинг улучшил показания модели и RMSE снизился. Тюнингованый XGBoost превзошел Random Forest.

4. **dvc.yaml**
    * Берет датасет forestfires.csv и с помощью dataloader.py возвращает разделенную выборку и передает ее Forestfirres_Prediction.py
    * Обучает модели на основе этих данных и вовзращает их веса


5. **app.py**
    * GET/ вовзращает информацию о здоровье сервиса
    * GET/info возвращает информацию об обученной модели (метрики и параметры)
    * POST/predict принимает json со входными данными и возвращает предсказание модели. 
    * Пример: curl -X POST http://localhost:8080/predict -H "Content-Type: application/json" -d '{"X":1,"Y":2,"FFMC":90,"DMC":100,"DC":500,"ISI":5,"temp":20,"RH":50,"wind":3,"rain":0,"month_apr":0,"month_aug":0,"month_dec":0,"month_feb":0,"month_jan":0,"month_jul":0,"month_jun":0,"month_mar":0,"month_may":0,"month_nov":0,"month_oct":0,"month_sep":0,"day_fri":0,"day_mon":0,"day_sat":0,"day_sun":0,"day_thu":0,"day_tue":0,"day_wed":1}' вернет {
  "prediction": 1.7611678838729858,
  "status": "ok"
}
   

6. **Dockerfile**
   * Образ нашего приложения, содержит все вышеперечисленные файлы
    * Чтобы построить образ, выполните docker build -t poliaanna/forestfires_prediction:latest .
    * Чтобы запустить приложение, выполните  docker run -p 8080:8080 poliaanna/forestfires_prediction:latest
   

7. **deployment.yaml**
    * Манифест k8s, управляющий 3 репликами приложения

8. **service.yaml**
   *  Манифест k8s, предоставляющий сетевой доступ к подам, которые управляются deployment
